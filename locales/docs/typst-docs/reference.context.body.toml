
[[main]]
en = """# Context
Sometimes, we want to create content that reacts to its location in the
document. This could be a localized phrase that depends on the configured text
language or something as simple as a heading number which prints the right
value based on how many headings came before it. However, Typst code isn't
directly aware of its location in the document. Some code at the beginning of
the source text could yield content that ends up at the back of the document."""
zh = """# 上下文
有时，我们希望创建响应其文档位置的内容。这可能是一个依赖于配置文本语言的本地化短语，或者像标题编号这样简单的东西，它根据前面有多少标题打印正确的值。然而，Typst 代码本身并不直接意识到它在文档中的位置。源文本开头的某些代码可能会产生位于文档末尾的内容。"""

[[main]]
en = """To produce content that is reactive to its surroundings, we must thus
specifically instruct Typst: We do this with the `{context}` keyword, which
precedes an expression and ensures that it is computed with knowledge of its
environment. In return, the context expression itself ends up opaque. We cannot
directly access whatever results from it in our code, precisely because it is
contextual: There is no one correct result, there may be multiple results in
different places of the document. For this reason, everything that depends on
the contextual data must happen inside of the context expression."""
zh = """为了产生响应其周围环境的内容，我们必须明确地指示 Typst：我们使用 `{context}` 关键字，它前面是一个表达式，并确保它以已知的环境计算。作为回报，上下文表达式本身变得不透明。我们无法直接访问来自它的任何结果，因为它是上下文的：没有一个是正确的结果，可能会有多个结果在文档的不同地方。因此，所有依赖于上下文数据的内容必须发生在上下文表达式内部。"""

[[main]]
en = """Aside from explicit context expressions, context is also established implicitly
in some places that are also aware of their location in the document:
[Show rules]($styling/#show-rules) provide context[^1] and numberings in the
outline, for instance, also provide the proper context to resolve counters."""
zh = """除了显式上下文表达式，上下文还在一些地方隐式建立：[显示规则]($styling/#show-rules) 提供上下文，例如大纲中的编号，也提供正确的上下文来解析计数器。"""

[[main]]
en = """## Style context
With set rules, we can adjust style properties for parts or the whole of our
document. We cannot access these without a known context, as they may change
throughout the course of the document. When context is available, we can
retrieve them simply by accessing them as fields on the respective element
function."""
zh = """## 样式上下文
使用设置规则，我们可以调整部分或整个文档的样式属性。我们无法在没有已知上下文的情况下访问这些属性，因为它们可能会在整个文档过程中发生变化。当上下文可用时，我们可以简单地通过访问相应元素函数上的字段来检索它们。"""

[[main]]
en = """```example
#set text(lang: "de")
#context text.lang
```"""

[[main]]
en = """As explained above, a context expression is reactive to the different
environments it is placed into. In the example below, we create a single context
expression, store it in the `value` variable and use it multiple times. Each use
properly reacts to the current surroundings."""
zh = """如上所述，上下文表达式对它被放置的不同环境是反应性的。在下面的示例中，我们创建一个单一的上下文表达式，将其存储在 `value` 变量中，并多次使用它。每次使用都正确地响应当前环境。"""

[[main]]
en = """```example
#let value = context text.lang
#value

#set text(lang: "de")
#value

#set text(lang: "fr")
#value
```"""

[[main]]
en = """Crucially, upon creation, `value` becomes opaque [content] that we cannot peek
into. It can only be resolved when placed somewhere because only then the
context is known. The body of a context expression may be evaluated zero, one,
or multiple times, depending on how many different places it is put into."""
zh = """至关重要的是，在创建时，`value` 变成一个不透明的 [内容]，我们无法窥视。它只能在放置在某个地方时才能解析，因为只有那时上下文才被知道。上下文表达式的内容可能被评估零次、一次或多次，这取决于它被放置了多少个不同的地方。"""

[[main]]
en = """## Location context
We've already seen that context gives us access to set rule values. But it can
do more: It also lets us know _where_ in the document we currently are, relative
to other elements, and absolutely on the pages. We can use this information to
create very flexible interactions between different document parts. This
underpins features like heading numbering, the table of contents, or page
headers dependent on section headings."""
zh = """## 位置上下文
我们已经看到上下文给了我们访问设置规则值的权限。但它还可以做更多：它还让我们知道文档中 _哪里_ 相对于其他元素，以及绝对在页面上。我们可以使用这些信息来创建非常灵活的不同文档部分之间的交互。这支持了像标题编号、目录或依赖于部分标题的页面标题等特性。"""

[[main]]
en = """Some functions like [`counter.get`]($counter.get) implicitly access the current
location. In the example below, we want to retrieve the value of the heading
counter. Since it changes throughout the document, we need to first enter a
context expression. Then, we use `get` to retrieve the counter's current value.
This function accesses the current location from the context to resolve the
counter value. Counters have multiple levels and `get` returns an array with the
resolved numbers. Thus, we get the following result:"""
zh = """一些函数，如 [`counter.get`]($counter.get) 隐式访问当前位置。在下面的示例中，我们想要检索标题计数器的值。由于它在整个文档中发生变化，我们需要首先进入一个上下文表达式。然后，我们使用 `get` 来检索计数器的当前值。该函数从上下文中访问当前位置来解析计数器值。计数器有多个级别，`get` 返回一个包含解析数字的数组。因此，我们得到以下结果："""

[[main]]
en = """```example
#set heading(numbering: "1.")

= Introduction
#lorem(5)

#context counter(heading).get()

= Background
#lorem(5)

#context counter(heading).get()
```"""

[[main]]
en = """For more flexibility, we can also use the [`here`] function to directly extract
the current [location] from the context. The example below
demonstrates this:"""
zh = """为了更大的灵活性，我们还可以使用 [`here`] 函数直接从上下文中提取当前 [位置]。下面的示例演示了这一点："""

[[main]]
en = """- We first have `{counter(heading).get()}`, which resolves to `{(2,)}` as
  before.
- We then use the more powerful  [`counter.at`] with [`here`], which in
  combination is equivalent to `get`, and thus get `{(2,)}`.
- Finally, we use `at` with a [label] to retrieve the value of the counter at a
  _different_ location in the document, in our case that of the introduction
  heading. This yields `{(1,)}`. Typst's context system gives us time travel
  abilities and lets us retrieve the values of any counters and states at _any_
  location in the document."""
zh = """- 我们首先有 `{counter(heading).get()}`，这与之前相同，解析为 `{(2,)}`。
- 然后，我们使用更强大的 [`counter.at`] 与 [`here`]，它们结合在一起等同于 `get`，因此得到 `{(2,)}`。
- 最后，我们使用 `at` 与一个 [标签] 来检索文档中 _不同_ 位置的计数器值，在我们的例子中是介绍标题的位置。这得到 `{(1,)}`。Typst 的上下文系统给了我们时间旅行能力，并让我们检索文档中 _任何_ 位置的任何计数器和状态的值。"""

[[main]]
en = """```example
#set heading(numbering: "1.")

= Introduction <intro>
#lorem(5)

= Background <back>
#lorem(5)

#context [
  #counter(heading).get() \\
  #counter(heading).at(here()) \\
  #counter(heading).at(<intro>)
]
```"""

[[main]]
en = """As mentioned before, we can also use context to get the physical position of
elements on the pages. We do this with the [`locate`] function, which works
similarly to `counter.at`: It takes a location or other [selector] that resolves
to a unique element (could also be a label) and returns the position on the
pages for that element."""
zh = """我们还可以使用上下文来获取元素在页面上的物理位置。我们使用 [`locate`] 函数来做到这一点，它类似于 `counter.at`：它接受一个位置或其他 [选择器]，解析为一个唯一的元素（也可以是标签），并返回该元素在页面上的位置。"""

[[main]]
en = """```example
Background is at: \\
#context locate(<back>).position()

= Introduction <intro>
#lorem(5)
#pagebreak()

= Background <back>
#lorem(5)
```"""

[[main]]
en = """There are other functions that make use of the location context, most
prominently [`query`]. Take a look at the
[introspection]($category/introspection) category for more details on those."""
zh = """还有其他函数利用位置上下文，最突出的是 [`query`]。查看 [内省]($category/introspection) 类别以获取更多详细信息。"""

[[main]]
en = """## Nested contexts
Context is also accessible from within function calls nested in context blocks.
In the example below, `foo` itself becomes a contextual function, just like
[`to-absolute`]($length.to-absolute) is."""
zh = """## 嵌套上下文
上下文也可以从嵌套在上下文块中的函数调用中访问。在下面的示例中，`foo` 本身成为上下文函数，就像 [`to-absolute`]($length.to-absolute) 一样。"""

[[main]]
en = """```example
#let foo() = 1em.to-absolute()
#context {
  foo() == text.size
}
```"""

[[main]]
en = """Context blocks can be nested. Contextual code will then always access the
innermost context. The example below demonstrates this: The first `text.lang`
will access the outer context block's styles and as such, it will **not**
see the effect of `{set text(lang: "fr")}`. The nested context block around the
second `text.lang`, however, starts after the set rule and will thus show
its effect."""
zh = """上下文块可以嵌套。上下文代码将始终访问最内层的上下文。下面的示例演示了这一点：第一个 `text.lang` 将访问外部上下文块的样式，因此它 **不会** 看到 `{set text(lang: "fr")}` 的效果。然而，第二个 `text.lang` 周围的嵌套上下文块在设置规则之后开始，因此将显示其效果。"""

[[main]]
en = """```example
#set text(lang: "de")
#context [
  #set text(lang: "fr")
  #text.lang \\
  #context text.lang
]
```"""

[[main]]
en = """You might wonder why Typst ignores the French set rule when computing the first
`text.lang` in the example above. The reason is that, in the general case, Typst
cannot know all the styles that will apply as set rules can be applied to
content after it has been constructed. Below, `text.lang` is already computed
when the template function is applied. As such, it cannot possibly be aware of
the language change to French in the template."""
zh = """您可能想知道为什么 Typst 在计算上面的第一个 `text.lang` 时忽略了法语设置规则。原因是，在一般情况下，Typst 无法知道所有将作为设置规则应用的内容。下面，当模板函数被应用时，`text.lang` 已经计算出来了。因此，它不可能知道模板中的法语变化。"""

[[main]]
en = """```example
#let template(body) = {
  set text(lang: "fr")
  upper(body)
}

#set text(lang: "de")
#context [
  #show: template
  #text.lang \\
  #context text.lang
]
```"""

[[main]]
en = """The second `text.lang`, however, _does_ react to the language change because
evaluation of its surrounding context block is deferred until the styles for it
are known. This illustrates the importance of picking the right insertion point for a context to get access to precisely the right styles."""
zh = """第二个 `text.lang` 确实对语言变化有反应，因为它的周围上下文块的评估被推迟到样式已知时。这说明了选择正确的插入点以获得精确的正确样式的上下文的重要性。"""

[[main]]
en = """The same also holds true for the location context. Below, the first
`{c.display()}` call will access the outer context block and will thus not see
the effect of `{c.update(2)}` while the second `{c.display()}` accesses the inner context and will thus see it."""
zh = """位置上下文也是如此。下面，第一个 `{c.display()}` 调用将访问外部上下文块，因此不会看到 `{c.update(2)}` 的效果，而第二个 `{c.display()}` 访问内部上下文，因此会看到它。"""

[[main]]
en = """```example
#let c = counter("mycounter")
#c.update(1)
#context [
  #c.update(2)
  #c.display() \\
  #context c.display()
]
```"""

[[main]]
en = """## Compiler iterations
To resolve contextual interactions, the Typst compiler processes your document
multiple times. For instance, to resolve a `locate` call, Typst first provides a
placeholder position, layouts your document and then recompiles with the known
position from the finished layout. The same approach is taken to resolve
counters, states, and queries. In certain cases, Typst may even need more than
two iterations to resolve everything. While that's sometimes a necessity, it may
also be a sign of misuse of contextual functions (e.g. of
[state]($state/#caution)). If Typst cannot resolve everything within five
attempts, it will stop and output the warning \"layout did not converge within 5
attempts.\""""
zh = """## 编译器迭代
为了解析上下文交互，Typst 编译器多次处理您的文档。例如，为了解析 `locate` 调用，Typst 首先提供一个占位符位置，布局您的文档，然后重新编译已知位置的布局。同样的方法用于解析计数器、状态和查询。在某些情况下，Typst 甚至可能需要超过两次迭代来解析所有内容。虽然有时这是必要的，但它也可能是上下文函数使用不当的迹象（例如，[状态]($state/#caution)）。如果 Typst 无法在五次尝试内解析所有内容，它将停止并输出警告 \"布局在五次尝试内未收敛。\""""

[[main]]
en = """A very careful reader might have noticed that not all of the functions presented
above actually make use of the current location. While
`{counter(heading).get()}` definitely depends on it,
`{counter(heading).at(<intro>)}`, for instance, does not. However, it still
requires context. While its value is always the same _within_ one compilation
iteration, it may change over the course of multiple compiler iterations. If one
could call it directly at the top level of a module, the whole module and its
exports could change over the course of multiple compiler iterations, which
would not be desirable."""
zh = """一个非常仔细的读者可能已经注意到，上面提到的所有函数实际上并没有充分利用当前位置。虽然 `{counter(heading).get()}` 肯定依赖于它，但 `{counter(heading).at(<intro>)}` 则不然。然而，它仍然需要上下文。虽然它的值在 _一次_ 编译迭代中总是相同的，但它可能会在多次编译迭代过程中发生变化。如果它可以直接在模块的顶层调用，整个模块及其导出可能会在多次编译迭代过程中发生变化，这并不是我们想要的。"""

[[main]]
en = """[^1]: Currently, all show rules provide styling context, but only show rules on
      [locatable]($location/#locatable) elements provide a location context."""
zh = """[^1]: 目前，所有显示规则都提供样式上下文，但只有 [可定位]($location/#locatable) 元素的显示规则提供位置上下文。"""
